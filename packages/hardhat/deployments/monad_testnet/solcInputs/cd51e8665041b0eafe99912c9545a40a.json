{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "contracts/MockYieldProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title MockYieldProvider\n * @dev Simulates a DeFi protocol (like Aave or Lido) where the principal is deposited\n * to earn yield. For demo purposes, the yield amount is manually set by the deployer\n * or the contract owner when settling the pool.\n */\ncontract MockYieldProvider {\n    address public owner;\n    mapping(address => uint256) public poolYields;\n\n    event PrincipalDeposited(address indexed poolAddress, uint256 amount);\n    event YieldSet(address indexed poolAddress, uint256 yieldAmount);\n    event PrincipalAndYieldReturned(address indexed poolAddress, uint256 totalReturn);\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner can call\");\n        _;\n    }\n\n    /**\n     * @dev Simulates the action of sending the pool's principal to a DeFi protocol.\n     * @param _poolAddress The address of the betting pool contract.\n     * @param _amount The principal amount (Sponsor + Participants deposits).\n     */\n    function depositPrincipal(address _poolAddress, uint256 _amount) public payable {\n        require(msg.value == _amount, \"Deposit amount mismatch\");\n        emit PrincipalDeposited(_poolAddress, _amount);\n        // Funds are held in this contract's balance\n    }\n\n    /**\n     * @dev Sets the simulated yield generated by the principal (called by the owner).\n     */\n    function setPoolYield(address _poolAddress, uint256 _yieldAmount) public onlyOwner {\n        poolYields[_poolAddress] = _yieldAmount;\n        emit YieldSet(_poolAddress, _yieldAmount);\n    }\n\n    /**\n     * @dev Returns the total funds (Principal + Yield) back to the Pool for distribution.\n     * @param _poolAddress The address of the betting pool contract.\n     * @param _totalAmount The total principal + yield to be returned.\n     */\n    function returnPrincipalAndYield(address _poolAddress, uint256 _totalAmount) public onlyOwner {\n        // Conceptually transfers funds from the DeFi protocol back to the pool\n        (bool success, ) = payable(_poolAddress).call{value: _totalAmount}(\"\");\n        require(success, \"Transfer failed\");\n\n        // Clear the yield record\n        delete poolYields[_poolAddress];\n\n        emit PrincipalAndYieldReturned(_poolAddress, _totalAmount);\n    }\n}\n\n"
    },
    "contracts/NoLossPredictionPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./MockYieldProvider.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title NoLossPredictionPool\n * @dev A prediction market where user principal is returned regardless of the outcome.\n * The prize pool is funded entirely by yield generated from DeFi lending.\n */\ncontract NoLossPredictionPool is Ownable {\n\n    // --- CONFIGURATION ---\n    uint256 public constant TICKET_FEE = 0.1 ether; // 0.1 MON per participation\n    uint256 public constant SPONSOR_YIELD_CUT_PERCENT = 40; // 40% of total yield goes to the sponsor\n\n    MockYieldProvider public immutable yieldProvider;\n\n    // --- STRUCTS & STORAGE ---\n    struct Pool {\n        uint256 poolId;\n        string question;\n        address sponsor;\n        uint256 sponsorDeposit;\n        uint256 participantCount;\n        uint256 totalPrincipal;\n        mapping(uint8 => uint256) outcomeTicketCount;\n        mapping(address => uint8) userBet;\n        mapping(address => bool) hasClaimed;\n        uint256 bettingEndTime;\n        bool isSettled;\n        uint8 winningOutcomeId;\n        uint256 totalYield;\n    }\n\n    uint256 public nextPoolId = 1;\n    mapping(uint256 => Pool) public pools;\n\n    // --- EVENTS & CONSTRUCTOR ---\n    event PoolCreated(uint256 indexed poolId, address indexed sponsor, string question);\n    event JoinedPool(uint256 indexed poolId, address indexed user, uint8 outcomeId, uint256 deposit);\n    event PoolSettled(uint256 indexed poolId, uint8 winningOutcomeId, uint256 totalYield);\n    event FundsClaimed(uint256 indexed poolId, address indexed user, uint256 amountClaimed);\n\n    constructor(address _yieldProviderAddress) Ownable(msg.sender) {\n        yieldProvider = MockYieldProvider(_yieldProviderAddress);\n    }\n\n    // --- MODIFIERS ---\n    modifier onlySponsor(uint256 _poolId) {\n        require(pools[_poolId].sponsor == msg.sender, \"Caller must be the sponsor\");\n        _;\n    }\n\n    modifier bettingOpen(uint256 _poolId) {\n        require(block.timestamp < pools[_poolId].bettingEndTime, \"Betting period has ended\");\n        require(!pools[_poolId].isSettled, \"Pool is already settled\");\n        _;\n    }\n\n    modifier notSettled(uint256 _poolId) {\n        require(!pools[_poolId].isSettled, \"Pool is already settled\");\n        _;\n    }\n\n    modifier isSettled(uint256 _poolId) {\n        require(pools[_poolId].isSettled, \"Pool is not yet settled\");\n        _;\n    }\n\n    // --- CORE FUNCTIONS ---\n\n    function createPool(\n        string memory _question,\n        uint256 _bettingDuration\n    ) external payable notSettled(nextPoolId) {\n        uint256 sponsorDeposit = msg.value;\n        require(sponsorDeposit > 0, \"Sponsor must deposit initial capital\");\n\n        Pool storage newPool = pools[nextPoolId];\n        newPool.poolId = nextPoolId;\n        newPool.question = _question;\n        newPool.sponsor = msg.sender;\n        newPool.sponsorDeposit = sponsorDeposit;\n        newPool.totalPrincipal = sponsorDeposit;\n        newPool.bettingEndTime = block.timestamp + _bettingDuration;\n\n        // Deposit principal to the yield generator\n        yieldProvider.depositPrincipal{value: sponsorDeposit}(address(this), sponsorDeposit);\n\n        emit PoolCreated(nextPoolId, msg.sender, _question);\n        nextPoolId++;\n    }\n\n    function joinPool(uint256 _poolId, uint8 _outcomeId) external payable bettingOpen(_poolId) {\n        Pool storage pool = pools[_poolId];\n        require(msg.value == TICKET_FEE, \"Must pay exactly the TICKET_FEE\");\n        require(pool.userBet[msg.sender] == 0, \"User already participated in this pool\");\n\n        pool.userBet[msg.sender] = _outcomeId;\n        pool.outcomeTicketCount[_outcomeId] = pool.outcomeTicketCount[_outcomeId] + 1;\n        pool.participantCount = pool.participantCount + 1;\n        pool.totalPrincipal = pool.totalPrincipal + TICKET_FEE;\n\n        // Deposit new ticket principal to the yield generator\n        yieldProvider.depositPrincipal{value: TICKET_FEE}(address(this), TICKET_FEE);\n\n        emit JoinedPool(_poolId, msg.sender, _outcomeId, TICKET_FEE);\n    }\n\n    function settlePool(\n        uint256 _poolId,\n        uint8 _winningOutcomeId,\n        uint256 _simulatedYield\n    ) external onlySponsor(_poolId) notSettled(_poolId) {\n        Pool storage pool = pools[_poolId];\n        require(block.timestamp >= pool.bettingEndTime, \"Betting period is not over yet\");\n        require(_winningOutcomeId > 0, \"Winning outcome must be valid\");\n\n        pool.isSettled = true;\n        pool.winningOutcomeId = _winningOutcomeId;\n        pool.totalYield = _simulatedYield;\n\n        // Set the yield in the mock provider\n        yieldProvider.setPoolYield(address(this), _simulatedYield);\n\n        // Return total funds (Principal + Yield) back to this contract\n        uint256 totalReturn = pool.totalPrincipal + _simulatedYield;\n        yieldProvider.returnPrincipalAndYield(address(this), totalReturn);\n\n        emit PoolSettled(_poolId, _winningOutcomeId, _simulatedYield);\n    }\n\n    function claimFunds(uint256 _poolId) external isSettled(_poolId) {\n        Pool storage pool = pools[_poolId];\n        uint256 claimAmount = 0;\n\n        // Sponsor Claim\n        if (msg.sender == pool.sponsor) {\n            require(!pool.hasClaimed[msg.sender], \"Sponsor has already claimed\");\n\n            uint256 sponsorYieldCut = (pool.totalYield * SPONSOR_YIELD_CUT_PERCENT) / 100;\n            claimAmount = pool.sponsorDeposit + sponsorYieldCut;\n\n            pool.hasClaimed[msg.sender] = true;\n        } \n        // Participant Claim\n        else if (pool.userBet[msg.sender] != 0) {\n            require(!pool.hasClaimed[msg.sender], \"Participant has already claimed\");\n\n            // Principal is always returned (NO LOSS)\n            claimAmount = TICKET_FEE;\n\n            // Add yield share for winners\n            if (pool.userBet[msg.sender] == pool.winningOutcomeId) {\n                uint256 remainingYield = pool.totalYield - ((pool.totalYield * SPONSOR_YIELD_CUT_PERCENT) / 100);\n                uint256 winningTickets = pool.outcomeTicketCount[pool.winningOutcomeId];\n                \n                if (winningTickets > 0) {\n                    uint256 yieldShare = remainingYield / winningTickets;\n                    claimAmount = claimAmount + yieldShare;\n                }\n            }\n\n            pool.hasClaimed[msg.sender] = true;\n        } else {\n            revert(\"Address is neither sponsor nor participant in this pool\");\n        }\n\n        // Send the funds\n        (bool success, ) = payable(msg.sender).call{value: claimAmount}(\"\");\n        require(success, \"ETH transfer failed\");\n\n        emit FundsClaimed(_poolId, msg.sender, claimAmount);\n    }\n\n    // --- VIEW FUNCTIONS ---\n\n    /**\n     * @dev Returns pool details. Note: This is a simplified version.\n     * For full details, you may need separate getter functions for mappings.\n     */\n    function getPoolDetails(uint256 _poolId) external view returns (\n        uint256 poolId,\n        string memory question,\n        address sponsor,\n        uint256 sponsorDeposit,\n        uint256 participantCount,\n        uint256 totalPrincipal,\n        uint256 bettingEndTime,\n        bool settled,\n        uint8 winningOutcomeId,\n        uint256 totalYield\n    ) {\n        Pool storage pool = pools[_poolId];\n        return (\n            pool.poolId,\n            pool.question,\n            pool.sponsor,\n            pool.sponsorDeposit,\n            pool.participantCount,\n            pool.totalPrincipal,\n            pool.bettingEndTime,\n            pool.isSettled,\n            pool.winningOutcomeId,\n            pool.totalYield\n        );\n    }\n\n    /**\n     * @dev Get user's bet for a specific pool\n     */\n    function getUserBet(uint256 _poolId, address _user) external view returns (uint8) {\n        return pools[_poolId].userBet[_user];\n    }\n\n    /**\n     * @dev Check if user has claimed for a pool\n     */\n    function hasUserClaimed(uint256 _poolId, address _user) external view returns (bool) {\n        return pools[_poolId].hasClaimed[_user];\n    }\n\n    /**\n     * @dev Get outcome ticket count for a pool\n     */\n    function getOutcomeTicketCount(uint256 _poolId, uint8 _outcomeId) external view returns (uint256) {\n        return pools[_poolId].outcomeTicketCount[_outcomeId];\n    }\n}\n\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}